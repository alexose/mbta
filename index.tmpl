<!DOCTYPE html>
<meta charset="utf-8">
<html>
<head>
  <!-- bower:css -->
  <!-- endbower -->
</head>
<body>
  <h1>MBTAVIZOMG</h1>
  <svg width="600" height="600" viewBox="0 0 100 100" preserveAspectRatio="xMinYMin meet"></svg>
  <!-- bower:js -->
  <script src="bower_components/d3/d3.js"></script>
  <script src="bower_components/lodash/lodash.js"></script>
  <!-- endbower -->
  <script>

/*! tiny Js Pub/Sub
 * http://anasnakawa.com/
 * Copyright (c) Anas Nakawa
 * inspired by Ben Alman's tiny one <https://gist.github.com/cowboy/661855>
 * MIT License
 */
(function( p ) {

  var e = p.e = {};

  p.publish = function( name, data ) {
    ( e[ name ] = e[ name ] || new Event( name ) ).data = data;
    dispatchEvent( e[ name ] );
  };

  p.subscribe = function( name, handler, context ) {
    addEventListener( name, handler.bind( context ) );
  };

  p.unsubscribe = function( name, handler, context ) {
    removeEventListener( name, handler.bind( context ) );
  };

})( this.pubsub = {} );

var data = {{data}};

var svg = d3.selectAll('svg');

var stations = _.chain(data.stops)
  .map(function(d){
    var obj = {
      incoming : [],
      outgoing : []
    }
    return [ d.parent_station + d.route_name, obj ]
  })
  .zipObject()
  .value()

// Map colors
var colors = {
  'Green Line':       'rgb(51, 160, 44)',
  'Red Line':         'rgb(227, 26, 28)',
  'Orange Line':      'rgb(255, 127, 0)',
  'Blue Line':        'rgb(31, 120, 180)',
  'Mattapan Trolley': 'rgb(227, 26, 28)'
};

function makeExtent(){
  var arr = _.chain(data.stops)
    .pluck(coords)
    .value();

  var x = _.chain(arr).pluck(0).value(),
    y = _.chain(arr).pluck(1).value();

  var obj = [
      [_.min(x), _.max(x)],
      [_.min(y), _.max(y)]
    ];

  // TODO: fix this stuff
  if (coords == 'geo'){
    obj[1].reverse();
  } else if (coords == 'spider'){

    // Add more vertical padding
    obj[1][0] -= 3;
    obj[1][1] += 3;
  }

  return obj;
};

// Create a graph of stations with to-and-from segments
function makeGraph(){

  data.segments.forEach(function(d){
    var stop = {
        start : data.stops[d.start],
        end : data.stops[d.end]
      },
      route = stop.start.route_name,
      station = {
        start : stations[stop.start.parent_station + route],
        end : stations[stop.end.parent_station + route]
      };

    d.segment = [
      [stop.start.x, stop.start.y],
      [stop.end.x, stop.end.y]
    ];

    d.color = colors[stop.start.route_name];

    station.start.outgoing.push(d);
    station.end.incoming.push(d);
  });
}

var lineMapping = d3.svg.line()
  .x(function(d) { return d[0]; })
  .y(function(d) { return d[1]; })
  .interpolate("linear");

function makeScale(){
  var padding = 2;
  return {
    x : d3.scale.linear().domain(extent[0]).range([0 + padding, 100 - padding]),
    y : d3.scale.linear().domain(extent[1]).range([0 + padding, 100 - padding])
  }
}

function mouseover(stop){
  console.log(stop.parent_station_name, stop);
}

var coords, extent, scale, initialized;

var dist = 1.4;

var stops = _.values(data.stops),
  segments = data.segments,
  vehicles = data.vehicles || [];

init();
function init(){
  coords = coords === 'spider' ? 'geo' : 'spider';
  extent = makeExtent();
  scale = makeScale();

  // Processs coordinates
  stops.forEach(function(d){
    d.x = scale.x(d[coords][0]);
    d.y = scale.y(d[coords][1]);
  });

  makeGraph();

  if (initialized){
    update();
  } else {
    draw(stops, segments, vehicles);
  }
  initialized = true;
}

function draw(stops, segments, vehicles){

  var circles = svg.selectAll('circle'),
      lines = svg.selectAll('line'),
      rects = svg.selectAll('rect');

  circles
    .data(stops)
    .enter()
      .append('circle')
        .on('mouseover', mouseover)
        .style('fill', function(d){ return colors[d.route_name]; });

  lines
    .data(segments)
    .enter()
      .append('path')
        .style('fill', function(d){ return d.color; })
        .style('stroke', 'black')
        .style('stroke-width', 0.1);

  update(0);
}

function update(time){

  time = time || 1000;

  var circles = svg.selectAll('circle'),
      lines = svg.selectAll('path'),
      rects = svg.selectAll('rect');

  circles
    .transition().duration(time)
      .attr('cy', function(d){ return d.y })
      .attr('cx', function(d){ return d.x })
      .attr('r', 1);

  lines
    .transition().duration(time)
      .attr('d', lineFunction);

  rects
    .data(vehicles)
    .enter()
      .append('rect')
        .transition().duration(time)
          .attr('width', 1)
          .attr('height', 1)
          .attr('x', function(d){ console.log(d); return d.x; })
          .attr('y', function(d){ return d.y; });
}

// Set up web socket
var ws = new WebSocket('{{socket}}');

ws.onopen = function(){
  console.log('Socket opened.');
};

ws.onmessage = function(message){
  var data = parse(message.data);
  pubsub.publish(data.name, data.data);
};

pubsub.subscribe('vehiclesbyroute', function(e){

  // Merge vehicles with existing vehicles
  // There's got to be a nice way to do this with lodash...
  var index = _.indexBy(vehicles, 'id');

  e.data.forEach(function(vehicle){
    
    // Processs coordinates
    vehicle.x = scale.x(vehicle[coords][0]);
    vehicle.y = scale.y(vehicle[coords][1]);

    index[vehicle.id] = vehicle;
  });

  // Clear vehicles array
  vehicles.slice(0, vehicles.length);

  var newArr = _.map(index);
  for (var i in newArr){
    vehicles.push(newArr[i]);
  }

  update();
});

function parse(json){
  try{
    return JSON.parse(json);
  } catch(e){
    console.log('Couldn\'t parse JSON via websocket.');
  }
}



// Adapted from https://github.com/mbtaviz/week/blob/gh-pages/main.js
function closestClockwise(line, lines) {
  var origAngle = angle(line.segment);
  lines = lines || [];
  var result = null;
  var minAngle = Infinity;
  lines.forEach(function (other) {
    if (same(other, line)) { return; }
    var thisAngle = angle(other.segment) + Math.PI;
    var diff = -normalize(thisAngle - origAngle);
    if (diff < minAngle) {
      minAngle = diff;
      result = other;
    }
  });
  return result;
}

function closestCounterClockwise(line, lines) {
  var origAngle = angle(line.segment);
  lines = lines || [];
  var result = null;
  var minAngle = Infinity;
  lines.forEach(function (other) {
    var thisAngle = angle(other.segment);
    var diff = normalize(origAngle - thisAngle);
    var absDiff = Math.abs(diff);
    if (absDiff < 0.2 || Math.abs(absDiff - Math.PI) < 0.2) { return; }
    if (diff < minAngle) {
      minAngle = diff;
      result = other;
    }
  });
  return result;
}

function same(a, b) {
  var sega = JSON.stringify(a.segment);
  var segb = JSON.stringify(b.segment);
  return sega === segb;
}

function normalize(angle) {
  return (Math.PI * 4 + angle) % (Math.PI * 2) - Math.PI;
}

function angle(p1, p2) {
  if (arguments.length === 1) {
    var origP1 = p1;
    p1 = origP1[0];
    p2 = origP1[1];
  }
  return Math.atan2((p2[1] - p1[1]), (p2[0] - p1[0]));
}

function offsetPoints(d) {
  var p1 = d.segment[0];
  var p2 = d.segment[1];
  var lineAngle = angle(p1, p2);
  var angle90 = lineAngle + Math.PI / 2;
  var p3 = [p2[0] + dist * Math.cos(angle90), p2[1] + dist * Math.sin(angle90)];
  var p4 = [p1[0] + dist * Math.cos(angle90), p1[1] + dist * Math.sin(angle90)];
  return [p4, p3];
}

function slope(line) {
  return (line[1][1] - line[0][1]) / (line[1][0] - line[0][0]);
}

function intercept(line) {
  // y = mx + b
  // b = y - mx
  return line[1][1] - slope(line) * line[1][0];
}

function intersect(line1, line2) {
  var m1 = slope(line1);
  var b1 = intercept(line1);
  var m2 = slope(line2);
  var b2 = intercept(line2);
  var m1Infinite = m1 === Infinity || m1 === -Infinity;
  var m2Infinite = m2 === Infinity || m2 === -Infinity;
  var x, y;
  if ((m1Infinite && m2Infinite) || Math.abs(m2 - m1) < 0.01) {
    return null;
  } else if (m1Infinite) {
    x = line1[0][0];
    // y = mx + b
    y = m2 * x + b2;
    return [x, y];
  } else if (m2Infinite) {
    x = line2[0][0];
    y = m1 * x + b1;
    return [x, y];
  } else {
    // return null;
    // x = (b2 - b1) / (m1 - m2)
    x = (b2 - b1) / (m1 - m2);
    y = m1 * x + b1;
    return [x, y];
  }
}

function length (a, b) {
  return Math.sqrt(Math.pow(b[1] - a[1], 2) + Math.pow(b[0] - a[0], 2));
}

function lineFunction(d) {
  var p1 = d.segment[0];
  var p2 = d.segment[1];
  var offsets = offsetPoints(d);
  var p3 = offsets[1];
  var p4 = offsets[0];
  var first;

  var stop = {
    start : data.stops[d.start],
    end : data.stops[d.end]
  };

  var station = {
    start : stations[stop.start.parent_station + stop.start.route_name],
    end : stations[stop.end.parent_station + stop.end.route_name],
  };

  first = closestClockwise(d, station.end.outgoing);
  if (first) {
    var outgoingPoints = offsetPoints(first);
    var newP3 = intersect(offsets, outgoingPoints);
    if (newP3) { p3 = newP3; }
  }
  first = closestCounterClockwise(d, station.start.incoming);
  if (first) {
    var incomingPoints = offsetPoints(first);
    var newP4 = intersect(offsets, incomingPoints);
    if (newP4) { p4 = newP4; }
  }

  return lineMapping([p1, p2, p3, p4, p1]);
}

  </script>
</body>
</html>

